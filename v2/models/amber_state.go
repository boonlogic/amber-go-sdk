// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// AmberState Current state of the model within the Amber state machine. One of: `Buffering`, `Autotuning`, `Learning`, `Monitoring`.
//
// During `Buffering`, the model simply collects data which will be used to automatically fit its clustering parameters. During this stage no analytic results are returned. Once the model has collected `bufferSamples` input patterns, it transitions to `Autotuning`.
//
// During `Autotuning`, the model continues to collect data while using the data from `Buffering` to automatically discover good values for the clustering parameters (`minVal`, `maxVal` and `percentVariation`). No analytic results are returned during this stage, which does not last longer than 200 requests. Once finished, the model is configured with the newly discovered parameters and trained using all data collected during `Buffering` and `Autotuning`. At that point the model transitions to `Learning`.
//
// During `Learning`, the model starts returning analytic results while establishing a baseline for the expected number of anomalies per unit time. It also begins returning analytic results. During this phase the underlying asset should operate in a mostly compliant mode, even though the model is highly tolerant of anomalies that occur during `Learning` (i.e. an anomalous pattern encountered here will be considered just as anomalous during `Monitoring`). `Learning` transitions to `Monitoring` once any of the following requirements are met:
// - the model's `sampleCount` surpasses `learningMaxSamples`
// - the model's `clusterCount` surpasses `learningMaxClusters`
// - `learningRateNumerator` or fewer new clusters were created within the last `learningRateDenominator` samples.
//
// During `Monitoring`, all learning stops and the model continues to return analytic results. The model will remain in `Monitoring` until it is either re-configured or `Learning` is enabled again using `PUT /config`.
//
// swagger:model amberState
type AmberState string

func NewAmberState(value AmberState) *AmberState {
	v := value
	return &v
}

const (

	// AmberStateBuffering captures enum value "Buffering"
	AmberStateBuffering AmberState = "Buffering"

	// AmberStateAutotuning captures enum value "Autotuning"
	AmberStateAutotuning AmberState = "Autotuning"

	// AmberStateLearning captures enum value "Learning"
	AmberStateLearning AmberState = "Learning"

	// AmberStateMonitoring captures enum value "Monitoring"
	AmberStateMonitoring AmberState = "Monitoring"
)

// for schema
var amberStateEnum []interface{}

func init() {
	var res []AmberState
	if err := json.Unmarshal([]byte(`["Buffering","Autotuning","Learning","Monitoring"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		amberStateEnum = append(amberStateEnum, v)
	}
}

func (m AmberState) validateAmberStateEnum(path, location string, value AmberState) error {
	if err := validate.EnumCase(path, location, value, amberStateEnum, true); err != nil {
		return err
	}
	return nil
}

// Validate validates this amber state
func (m AmberState) Validate(formats strfmt.Registry) error {
	var res []error

	// value enum
	if err := m.validateAmberStateEnum("", "body", m); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// ContextValidate validates this amber state based on context it is used
func (m AmberState) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}
